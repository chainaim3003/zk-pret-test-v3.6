/**
 * Simplified compliance fields analysis
 */
function analyzeComplianceFields(complianceData: any) {
  return {
    isEntityActive: complianceData.entity_status.toString().includes('ACTIVE'),
    isRegistrationIssued: complianceData.registration_status.toString().includes('ISSUED'),
    isConformityOk: complianceData.conformity_flag.toString().includes('CONFORMING'),
    hasValidDates: true, // Simplified
    hasValidLEI: complianceData.lei.toString().length > 0
  };
}

/**
 * Simplified compliance field logging
 */
function logComplianceFieldAnalysis(complianceData: any, isCompliant: Bool, phase: string) {
  console.log(`üìä ${phase} Compliance Analysis:`);
  console.log(`  ‚Ä¢ LEI: ${complianceData.lei.toString()}`);
  console.log(`  ‚Ä¢ Entity Status: ${complianceData.entity_status.toString()}`);
  console.log(`  ‚Ä¢ Registration Status: ${complianceData.registration_status.toString()}`);
  console.log(`  ‚Ä¢ Overall Compliant: ${isCompliant.toJSON()}`);
}

/**
 * GLEIF Multi-Company Verifier
 * Pure verification logic using existing deployed contract
 * 
 * Responsibilities:
 * ‚úÖ Environment detection and contract loading from config
 * ‚úÖ Verify contract accessibility
 * ‚úÖ GLEIF data fetching for companies
 * ‚úÖ ZK proof generation and verification
 * ‚úÖ Multi-company compliance tracking
 * ‚úÖ Detailed reporting and analytics
 */

import * as dotenv from 'dotenv';
dotenv.config();

// Import o1js directly
import { Field, Mina, PrivateKey, PublicKey, AccountUpdate, CircuitString, Poseidon, Signature, MerkleTree, UInt64, Bool, fetchAccount, UInt32 } from 'o1js';

// Import ZK programs and contracts
import { GLEIFOptim } from '../../zk-programs/with-sign/GLEIFOptimZKProgram.js';
import { GLEIFOptimMultiCompanySmartContract } from '../../contracts/with-sign/GLEIFOptimMultiCompanySmartContract.js';

// Import infrastructure components
import { 
  environmentManager,
  compilationManager,
  initializeOracleRegistry,
  getDeployerAccount,
  getDeployerKey,
  getSenderAccount,
  getSenderKey
} from '../../infrastructure/index.js';

/**
 * Simplified function to create merkle tree from GLEIF data
 */
function createSimpleGLEIFMerkleTree(apiResponse: GLEIFAPIResponse) {
  const data = apiResponse.data[0];
  const tree = new MerkleTree(8); // Height 8 for compatibility
  
  // Extract basic fields
  const extractedData = {
    lei: data.attributes.lei,
    legalName: data.attributes.entity?.legalName?.name || '',
    entityStatus: data.attributes.entity?.status || '', // Fixed: use 'status' not 'entityStatus'
    registrationStatus: data.attributes.registration?.status || '', // Fixed: use 'status' not 'registrationStatus'
    conformityFlag: data.attributes.conformityFlag || '', // Fixed: use top-level conformityFlag
    initialRegistrationDate: data.attributes.registration?.initialRegistrationDate || '',
    lastUpdateDate: data.attributes.registration?.lastUpdateDate || '',
    nextRenewalDate: data.attributes.registration?.nextRenewalDate || '',
    managingLou: data.attributes.registration?.managingLou || '',
    bicCodes: data.attributes.bic?.map((b: any) => b.bic).join(',') || '',
    micCodes: data.attributes.mic?.map((m: any) => m.mic).join(',') || ''
  };
  
  // Debug: Log extracted data
  console.log('üìä Extracted Data:');
  console.log(`  ‚Ä¢ LEI: ${extractedData.lei}`);
  console.log(`  ‚Ä¢ Entity Status: ${extractedData.entityStatus}`);
  console.log(`  ‚Ä¢ Registration Status: ${extractedData.registrationStatus}`);
  console.log(`  ‚Ä¢ Conformity Flag: ${extractedData.conformityFlag}`);
  
  // Create simple field values and add to tree
  const fields = [
    // Convert LEI to hash instead of direct Field conversion to avoid BigInt errors
    Poseidon.hash([CircuitString.fromString(data.attributes.lei.slice(0, 20)).hash()]), // LEI hash
    Field(extractedData.entityStatus === 'ACTIVE' ? 1 : 0),
    Field(extractedData.registrationStatus === 'ISSUED' ? 1 : 0),
    Field(extractedData.conformityFlag === 'CONFORMING' ? 1 : 0),
    Field(1), // placeholder for dates
    Field(1), // placeholder for dates
    Field(1), // placeholder for BIC
    Field(1)  // placeholder for MIC
  ];
  
  fields.forEach((field, index) => {
    tree.setLeaf(BigInt(index), field);
  });
  
  return {
    tree,
    extractedData,
    fieldCount: fields.length
  };
}

/**
 * Simplified function to create compliance data with proper null checks
 */
function createSimpleComplianceData(extractedData: any, merkleRoot: Field): any {
  // Add null checks and fallbacks for all fields
  const lei = extractedData.lei || 'UNKNOWN';
  const legalName = extractedData.legalName || 'UNKNOWN';
  const entityStatus = extractedData.entityStatus || 'UNKNOWN';
  const registrationStatus = extractedData.registrationStatus || 'UNKNOWN';
  const conformityFlag = extractedData.conformityFlag || 'UNKNOWN';
  const bicCodes = extractedData.bicCodes || '';
  const micCodes = extractedData.micCodes || '';
  const managingLou = extractedData.managingLou || '';
  
  return {
    lei: CircuitString.fromString(lei.slice(0, 32)), // Truncate if needed
    name: CircuitString.fromString(legalName.slice(0, 32)),
    entity_status: CircuitString.fromString(entityStatus.slice(0, 16)),
    registration_status: CircuitString.fromString(registrationStatus.slice(0, 16)),
    conformity_flag: CircuitString.fromString(conformityFlag.slice(0, 16)),
    initialRegistrationDate: CircuitString.fromString(new Date().toISOString().slice(0, 32)),
    lastUpdateDate: CircuitString.fromString(new Date().toISOString().slice(0, 32)),
    nextRenewalDate: CircuitString.fromString(new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString().slice(0, 32)),
    bic_codes: CircuitString.fromString(bicCodes.slice(0, 32)),
    mic_codes: CircuitString.fromString(micCodes.slice(0, 32)),
    managing_lou: CircuitString.fromString(managingLou.slice(0, 32)),
    merkle_root: merkleRoot // Fixed: use merkle_root to match ZK program structure
  };
}

/**
 * Simplified function to create company record
 */
function createSimpleCompanyRecord(complianceData: any, isCompliant: Bool, timestamp: UInt64, hasValidDates: boolean): any {
  return {
    leiHash: Poseidon.hash([Field(complianceData.lei.toString())]),
    legalNameHash: Poseidon.hash([Field(complianceData.name.toString())]),
    jurisdictionHash: Field(1),
    isCompliant: isCompliant,
    complianceScore: Field(isCompliant.toBoolean() ? 100 : 0),
    totalVerifications: UInt32.from(1),
    passedVerifications: UInt32.from(isCompliant.toBoolean() ? 1 : 0),
    failedVerifications: UInt32.from(isCompliant.toBoolean() ? 0 : 1),
    consecutiveFailures: UInt32.from(isCompliant.toBoolean() ? 0 : 1),
    lastVerificationTime: timestamp,
    firstVerificationTime: timestamp,
    lastPassTime: isCompliant.toBoolean() ? timestamp : UInt64.from(0),
    lastFailTime: isCompliant.toBoolean() ? UInt64.from(0) : timestamp
  };
}

/**
 * Get GLEIF signer key for oracle signatures
 * Uses the GLEIF oracle's private key from infrastructure
 */
function getGleifSignerKey(): PrivateKey {
  try {
    // Use GLEIF deployer key as signer for oracle signatures
    return getDeployerKey('GLEIF');
  } catch (error) {
    console.warn('Could not get GLEIF key from infrastructure, using random key for testing');
    return PrivateKey.random();
  }
}

// Import shared utilities
import {
  getTransactionFee,
  checkContractAccessibility,
  displayVerificationCosts,
  displayVerificationSummary,
  getContractDeploymentInfo,
  displayBuildEnvironmentInfo,
  validateBuildEnvironment
} from './GLEIFMultiCompanySharedUtils.js';

// Import GLEIF utilities
import {
  fetchGLEIFDataWithFullLogging,
  GLEIFAPIResponse,
  analyzeGLEIFCompliance
} from './GLEIFEnhancedUtils.js';

// Import the working verification function
import { getGLEIFOptimMultiCompanyRefactoredInfrastructureVerificationWithSignUtils } from './GLEIFOptimMultiCompanyRefactoredInfrastructureTestWithSignUtils.js';

// Import field indices
import { GLEIF_FIELD_INDICES } from './GLEIFFieldIndices.js';

// Types

interface VerificationResult {
  companyName: string;
  lei: string;
  isCompliant: boolean;
  complianceScore: number;
  verificationTime: string;
  complianceFields?: any;
  businessRules?: any;
  stateChanges?: any;
  error?: string;
}





/**
 * Main verification function for multiple companies
 */
export async function verifyGLEIFMultiCompanyCompliance(
  companyNames: string[],
  useExistingContract: boolean = true
): Promise<{
  proofs: any[];
  totalCompanies: number;
  companyRegistry: LocalCompanyRegistry;
  contractState: any;
  globalStats: any;
  verificationResults: VerificationResult[];
  contractAddress: string;
}> {
  
  console.log('\nüîç GLEIF Multi-Company Compliance Verifier');
  console.log('='.repeat(60));
  console.log(`üè¢ Companies to verify: ${companyNames.length}`);
  console.log(`üìã Use existing contract: ${useExistingContract ? 'YES' : 'NO'}`);

  try {
    // =================================== Validate BUILD_ENV ===================================
    console.log('\nüìã Step 0: Validating BUILD_ENV configuration...');
    
    const envValidation = validateBuildEnvironment();
    if (!envValidation.isValid) {
      console.error('‚ùå BUILD_ENV validation failed:');
      envValidation.issues.forEach(issue => console.error(`  ‚Ä¢ ${issue}`));
      throw new Error('Invalid BUILD_ENV configuration');
    }
    
    // Display BUILD_ENV information
    const buildInfo = displayBuildEnvironmentInfo();
    console.log(`‚úÖ BUILD_ENV validation passed`);
    console.log(`üìÅ Will read contract address from: ${buildInfo.configFile}`);
    
    // =================================== Initialize Infrastructure ===================================
    console.log('\nüìã Step 1: Initializing infrastructure components...');
    
    // Get environment details
    const currentEnvironment = environmentManager.getCurrentEnvironment();
    const shouldConnectToDevnet = environmentManager.shouldConnectToDevnet();
    
    console.log(`‚úÖ Environment: ${currentEnvironment}`);
    console.log(`üåê Connect to DEVNET: ${shouldConnectToDevnet}`);
    
    // Initialize compilation manager
    await compilationManager.initialize();
    console.log('‚úÖ Compilation Manager initialized');

    // =================================== Setup Blockchain Environment ===================================
    console.log('\nüìã Step 2: Setting up blockchain environment...');
    
    let senderAccount: any;
    let senderKey: any;
    
    if (currentEnvironment === 'TESTNET' && shouldConnectToDevnet) {
      // DEVNET MODE: Use Oracle Registry funded accounts
      console.log('üåê DEVNET environment detected - using funded Oracle accounts');
      
      // ‚úÖ CRITICAL: Initialize Oracle Registry BEFORE trying to get accounts
      console.log('üîß Initializing Oracle Registry for DEVNET...');
      await initializeOracleRegistry();
      console.log('‚úÖ Oracle Registry initialized successfully');
      
      // Establish DEVNET connection
      console.log('üîß Connecting to DEVNET GraphQL endpoint...');
      const devnetNetwork = Mina.Network('https://api.minascan.io/node/devnet/v1/graphql');
      Mina.setActiveInstance(devnetNetwork);
      console.log('‚úÖ DEVNET connection established');
      
      // Get funded Oracle accounts for sending transactions
      try {
        senderAccount = getSenderAccount('GLEIF');
        senderKey = getSenderKey('GLEIF');
        
        // Verify sender account
        await fetchAccount({ publicKey: senderAccount });
        const accountInfo = Mina.getAccount(senderAccount);
        const balance = Number(accountInfo.balance.toString()) / 1e9;
        
        console.log('‚úÖ Blockchain environment initialized with DEVNET Oracle accounts');
        console.log(`  üéØ GLEIF Sender: ${senderAccount.toBase58()}`);
        console.log(`  üí∞ Balance: ${balance} MINA`);
        console.log('  üåê Connected to: MINA DEVNET via Oracle Registry');
        
        if (balance < 1) {
          throw new Error(`Insufficient balance: ${balance} MINA (need at least 1 MINA for verification transactions)`);
        }
        
      } catch (oracleError) {
        console.error('‚ùå Failed to get Oracle accounts:', oracleError);
        throw new Error(`Oracle Registry not properly initialized for DEVNET: ${oracleError}`);
      }
      
    } else {
      // LOCAL MODE: Use LocalBlockchain for development
      console.log(`üîß ${currentEnvironment} environment - creating LocalBlockchain for development`);
      
      const useProof = false;
      const Local = await Mina.LocalBlockchain({ proofsEnabled: useProof });
      Mina.setActiveInstance(Local);

      senderAccount = Local.testAccounts[1].key.toPublicKey(); // Use second account for sending
      senderKey = Local.testAccounts[1].key;

      console.log('‚úÖ Blockchain environment initialized with LocalBlockchain accounts');
      console.log(`  üîß Local Sender: ${senderAccount.toBase58()}`);
      console.log('  üè† Mode: Local development blockchain');
    }

    // =================================== Load Existing Contract ===================================
    console.log('\nüìã Step 3: Loading existing smart contract...');
    
    const currentConfig = await environmentManager.getCurrentConfig();
    const existingContract = currentConfig.deployments?.contracts?.GLEIFOptimMultiCompanySmartContract;
    
    if (!existingContract || !existingContract.address) {
      throw new Error(`No existing contract found in config. Please deploy first using GLEIFMultiCompanySmartContractDeployer.ts`);
    }
    
    const contractAddress = PublicKey.fromBase58(existingContract.address);
    console.log(`‚úÖ Found existing contract: ${existingContract.address}`);
    console.log(`üìÖ Deployed at: ${existingContract.deployedAt || 'Unknown'}`);
    console.log(`üîó Transaction: ${existingContract.transactionHash || 'Unknown'}`);
    
    // Check if contract is accessible
    const isAccessible = await checkContractAccessibility(contractAddress);
    if (!isAccessible) {
      throw new Error(`Contract is not accessible. It may still be deploying or have deployment issues.`);
    }
    
    console.log(`‚úÖ Contract is accessible and ready for verification`);

    // =================================== Compile Contracts ===================================
    console.log('\nüìã Step 4: Compiling contracts...');
    
    // Compile GLEIFOptim first
    if (!compilationManager.isCompiled('GLEIFOptim')) {
      console.log('üîß Compiling GLEIFOptim...');
      await GLEIFOptim.compile();
      console.log('‚úÖ GLEIFOptim compiled and cached');
    } else {
      console.log('‚úÖ GLEIFOptim already compiled (cached)');
    }
    
    // Compile main contract
    if (!compilationManager.isCompiled('GLEIFOptimMultiCompanySmartContract')) {
      console.log('üîß Compiling GLEIFOptimMultiCompanySmartContract...');
      await GLEIFOptimMultiCompanySmartContract.compile();
      console.log('‚úÖ GLEIFOptimMultiCompanySmartContract compiled and cached');
    } else {
      console.log('‚úÖ GLEIFOptimMultiCompanySmartContract already compiled (cached)');
    }

    // =================================== Initialize Contract Instance ===================================
    console.log('\nüìã Step 5: Initializing contract instance...');
    
    const zkApp = new GLEIFOptimMultiCompanySmartContract(contractAddress);
    
    // Get initial contract state
    console.log('üîÑ Fetching initial contract state...');
    await fetchAccount({ publicKey: contractAddress });
    const initialState = zkApp.getRegistryInfo();
    const initialStateWithPercentage = addCompliancePercentage(initialState);
    
    console.log(`‚úÖ Contract initialized successfully`);
    console.log(`üìä Initial state:`);
    console.log(`  ‚Ä¢ Total Companies: ${initialState.totalCompaniesTracked.toString()}`);
    console.log(`  ‚Ä¢ Compliant Companies: ${initialState.compliantCompaniesCount.toString()}`);
    console.log(`  ‚Ä¢ Global Compliance Score: ${initialStateWithPercentage.compliancePercentage}%`);
    console.log(`  ‚Ä¢ Total Verifications: ${initialState.totalVerificationsGlobal.toString()}`);

    // =================================== Initialize Company Registry ===================================
    const companyRegistry = new LocalCompanyRegistry();
    const proofs = [];
    const verificationResults: VerificationResult[] = [];

    // =================================== Process Each Company ===================================
    for (let i = 0; i < companyNames.length; i++) {
      const companyName = companyNames[i];
      console.log(`\n${'='.repeat(80)}`);
      console.log(`üè¢ Verifying Company ${i + 1}/${companyNames.length}: ${companyName}`);
      console.log(`${'='.repeat(80)}`);

      try {
        // =================================== Fetch GLEIF Data ===================================
        console.log(`\nüì° Fetching GLEIF data for ${companyName}...`);
        const apiResponse: GLEIFAPIResponse = await fetchGLEIFDataWithFullLogging(companyName);
        console.log(`‚úÖ GLEIF data fetched successfully for ${companyName}`);

        // =================================== Analyze Compliance ===================================
        console.log(`\nüîç Analyzing compliance for ${companyName}...`);
        const complianceAnalysis = analyzeGLEIFCompliance(apiResponse);
        console.log(`üìä Compliance Score: ${complianceAnalysis.complianceScore}%`);
        console.log(`‚úÖ Is Compliant: ${complianceAnalysis.isCompliant}`);
        
        if (complianceAnalysis.issues.length > 0) {
          console.log(`‚ö†Ô∏è Issues found:`);
          complianceAnalysis.issues.forEach((issue: string, index: number) => {
            console.log(`  ${index + 1}. ${issue}`);
          });
        }

        // =================================== Create Comprehensive Merkle Tree ===================================
        console.log(`\nüå≥ Creating comprehensive Merkle tree for ${companyName}...`);
        const { tree, extractedData, fieldCount } = createSimpleGLEIFMerkleTree(apiResponse);
        console.log(`‚úÖ Merkle tree created with ${fieldCount} fields`);

        // =================================== Prepare ZK Proof Data ===================================
        console.log(`\nüîê Preparing ZK proof data for ${companyName}...`);
        const merkleRoot = tree.getRoot();
        const currentTimestamp = UInt64.from(Date.now());
        
        // Create optimized compliance data
        const complianceData = createSimpleComplianceData(extractedData, merkleRoot);
        
        // Generate merkle witnesses for the 8 compliance fields (matching ZK program)
        const entityStatusWitness = new MerkleWitness8(tree.getWitness(BigInt(GLEIF_FIELD_INDICES.entity_status)));
        const registrationStatusWitness = new MerkleWitness8(tree.getWitness(BigInt(GLEIF_FIELD_INDICES.registration_status)));
        const conformityFlagWitness = new MerkleWitness8(tree.getWitness(BigInt(GLEIF_FIELD_INDICES.conformity_flag)));
        const lastUpdateWitness = new MerkleWitness8(tree.getWitness(BigInt(GLEIF_FIELD_INDICES.lastUpdateDate)));
        const nextRenewalWitness = new MerkleWitness8(tree.getWitness(BigInt(GLEIF_FIELD_INDICES.nextRenewalDate)));
        const leiWitness = new MerkleWitness8(tree.getWitness(BigInt(GLEIF_FIELD_INDICES.lei)));
        const bicWitness = new MerkleWitness8(tree.getWitness(BigInt(GLEIF_FIELD_INDICES.bic_codes)));
        const micWitness = new MerkleWitness8(tree.getWitness(BigInt(GLEIF_FIELD_INDICES.mic_codes)));

        // =================================== Oracle Signature (Semantic Oracle Manager) ===================================
        console.log(`\nüîè Generating oracle signature for ${companyName}...`);
        const gleifSignerPrivateKey = getGleifSignerKey();
        const oracleSignature = Signature.create(gleifSignerPrivateKey, [merkleRoot]);
        console.log('‚úÖ Oracle signature generated');

        // =================================== Generate ZK Proof ===================================
        console.log(`\n‚ö° Generating ZK proof for ${companyName}...`);
        console.log(`üìä Proving compliance for: ${complianceData.name.toString()}`);
        console.log(`üÜî LEI: ${complianceData.lei.toString()}`);
        console.log(`üìã Entity Status: ${complianceData.entity_status.toString()}`);

        const proof = await GLEIFOptim.proveOptimizedCompliance(
          currentTimestamp,
          complianceData,
          oracleSignature,
          entityStatusWitness,
          registrationStatusWitness,
          conformityFlagWitness,
          lastUpdateWitness,
          nextRenewalWitness,
          leiWitness,
          bicWitness,
          micWitness,
        );
        console.log(`‚úÖ ZK proof generated successfully for ${companyName}`);
        proofs.push(proof);

        // =================================== Add Company to Registry ===================================
        console.log(`\nüìã Adding ${companyName} to company registry...`);
        const isCompliant = proof.publicOutput.isGLEIFCompliant;
        const companyRecord = createSimpleCompanyRecord(complianceData, isCompliant, currentTimestamp, true);
        const lei = complianceData.lei.toString();
        
        // Add company to registry and get witness
        const companyWitness = companyRegistry.addOrUpdateCompany(lei, companyRecord);
        console.log(`‚úÖ Company added to registry. Total companies: ${companyRegistry.getTotalCompanies()}`);

        // =================================== Show Contract State BEFORE Verification ===================================
        console.log(`\nüìä Smart Contract State BEFORE Verification:`);
        
        // Fetch account state from DEVNET before reading
        console.log(`üîÑ Fetching zkApp account state from DEVNET...`);
        await fetchAccount({ publicKey: contractAddress });
        
        const stateBefore = zkApp.getRegistryInfo();
        const stateBeforeWithPercentage = addCompliancePercentage(stateBefore);
        console.log(`  Total Companies: ${stateBefore.totalCompaniesTracked.toString()}`);
        console.log(`  Compliant Companies: ${stateBefore.compliantCompaniesCount.toString()}`);
        console.log(`  Global Compliance Score: ${stateBeforeWithPercentage.compliancePercentage}%`);
        console.log(`  Total Verifications: ${stateBefore.totalVerificationsGlobal.toString()}`);
        console.log(`  Companies Root Hash: ${stateBefore.companiesRootHash.toString()}`);
        console.log(`  Registry Version: ${stateBefore.registryVersion.toString()}`);
        
        // =================================== Show Company Compliance Data ===================================
        console.log('\nüìã Company Compliance Data:');
        console.log(`  Company: ${companyName}`);
        console.log(`  LEI: ${complianceData.lei.toString()}`);
        console.log(`  Legal Name: ${complianceData.name.toString()}`);
        console.log(`  Entity Status: ${complianceData.entity_status.toString()}`);
        console.log(`  Registration Status: ${complianceData.registration_status.toString()}`);
        console.log(`  Conformity Flag: ${complianceData.conformity_flag.toString()}`);
        console.log(`  Initial Registration: ${complianceData.initialRegistrationDate.toString()}`);
        console.log(`  Last Update: ${complianceData.lastUpdateDate.toString()}`);
        console.log(`  Next Renewal: ${complianceData.nextRenewalDate.toString()}`);
        console.log(`  BIC Codes: ${complianceData.bic_codes.toString()}`);
        console.log(`  MIC Codes: ${complianceData.mic_codes.toString()}`);
        console.log(`  Managing LOU: ${complianceData.managing_lou.toString()}`);
        console.log(`  üîÆ Is GLEIF Compliant (ZK Proof): ${isCompliant.toJSON()}`);
        console.log(`  üìä Compliance Score (Analysis): ${complianceAnalysis.complianceScore}%`);
        console.log(`  üïí Verification Time: ${new Date(Number(currentTimestamp.toString())).toISOString()}`);
        
        // Show compliance field analysis
        logComplianceFieldAnalysis(complianceData, isCompliant, 'Pre-Verification');
        
        // =================================== Verify Proof on Multi-Company Smart Contract ===================================
        console.log(`\nüîç Verifying proof on multi-company smart contract for ${companyName}...`);
        console.log(`‚ö° Executing smart contract verification transaction...`);
        console.log(`üîê Submitting ZK proof to blockchain...`);

        // Create proper MerkleMapWitness for the companies map
        const { MerkleMap, MerkleMapWitness } = await import('o1js');
        const companiesMap = new MerkleMap();
        
        // Create company key for the map
        const companyLEIHash = complianceData.lei.hash();
        const companyNameHash = complianceData.name.hash();
        const companyKeyField = Poseidon.hash([companyLEIHash, companyNameHash]);
        
        // Get witness for the company key (should prove non-existence for new company)
        const companiesMapWitness = companiesMap.getWitness(companyKeyField);

        // Get appropriate fee for current environment
        const verificationFee = getTransactionFee(currentEnvironment);
        console.log(`üí∞ Using verification fee: ${verificationFee.toString()} nanomina (${Number(verificationFee.toString()) / 1e9} MINA)`);

        const txn = await Mina.transaction(
          {
            sender: senderAccount,
            fee: verificationFee,
          },
          async () => {
            await zkApp.verifyOptimizedComplianceWithProof(proof, companyWitness, companyRecord, companiesMapWitness);
          }
        );

        await txn.prove();
        const verificationResult = await txn.sign([senderKey]).send();

        // Wait for transaction to be included before fetching state
        console.log(`‚è≥ Waiting for transaction to be included in DEVNET...`);
        try {
          await verificationResult.wait();
          console.log(`‚úÖ Transaction confirmed on DEVNET`);
        } catch (waitError: any) {
          console.log(`‚ö†Ô∏è Transaction wait failed, but proceeding: ${waitError.message}`);
        }

        console.log(`\n‚úÖ SMART CONTRACT VERIFICATION COMPLETED`);
        console.log(`üìã Company ${companyName} verification recorded on blockchain`);
        console.log(`üìã Transaction hash: ${verificationResult.hash}`);
        console.log(`üîÑ Verification Status: ${isCompliant.toJSON() ? 'COMPLIANT' : 'NON-COMPLIANT'}`);
        
        // =================================== Show Contract State AFTER Verification ===================================
        console.log('\nüìä Contract state AFTER verification:');
        
        // Fetch updated account state from DEVNET after verification
        console.log(`üîÑ Fetching updated zkApp account state from DEVNET...`);
        await fetchAccount({ publicKey: contractAddress });
        
        const stateAfter = zkApp.getRegistryInfo();
        const stateAfterWithPercentage = addCompliancePercentage(stateAfter);
        console.log(`  Total Companies: ${stateAfter.totalCompaniesTracked.toString()}`);
        console.log(`  Compliant Companies: ${stateAfter.compliantCompaniesCount.toString()}`);
        console.log(`  Global Compliance Score: ${stateAfterWithPercentage.compliancePercentage}%`);
        console.log(`  Total Verifications: ${stateAfter.totalVerificationsGlobal.toString()}`);
        console.log(`  Companies Root Hash: ${stateAfter.companiesRootHash.toString()}`);
        console.log(`  Registry Version: ${stateAfter.registryVersion.toString()}`);
        
        // =================================== Show Verification Statistics ===================================
        console.log('\nüìä VERIFICATION STATISTICS:');
        console.log(`  üìà Total Verifications: ${companyRecord.totalVerifications.toString()}`);
        console.log(`  ‚úÖ Passed Verifications: ${companyRecord.passedVerifications.toString()}`);
        console.log(`  ‚ùå Failed Verifications: ${companyRecord.failedVerifications.toString()}`);
        console.log(`  üîÑ Consecutive Failures: ${companyRecord.consecutiveFailures.toString()}`);
        
        // Calculate success rate with proper zero check
        const totalVerificationsNum = Number(companyRecord.totalVerifications.toString());
        const passedVerificationsNum = Number(companyRecord.passedVerifications.toString());
        const successRatePercent = totalVerificationsNum === 0 ? 0 : Math.round((passedVerificationsNum / totalVerificationsNum) * 100);
        
        console.log(`  üìä Success Rate: ${successRatePercent}%`);
        console.log(`  üïí First Verification: ${new Date(Number(companyRecord.firstVerificationTime.toString())).toISOString()}`);
        console.log(`  üïê Last Verification: ${new Date(Number(companyRecord.lastVerificationTime.toString())).toISOString()}`);
        
        // Show state changes
        console.log('\nüìà STATE CHANGES:');
        console.log(`  üìä Total Companies: ${stateBefore.totalCompaniesTracked.toString()} ‚Üí ${stateAfter.totalCompaniesTracked.toString()}`);
        console.log(`  ‚úÖ Compliant Companies: ${stateBefore.compliantCompaniesCount.toString()} ‚Üí ${stateAfter.compliantCompaniesCount.toString()}`);
        console.log(`  üìà Global Compliance Score: ${stateBeforeWithPercentage.compliancePercentage}% ‚Üí ${stateAfterWithPercentage.compliancePercentage}%`);
        console.log(`  üî¢ Total Verifications: ${stateBefore.totalVerificationsGlobal.toString()} ‚Üí ${stateAfter.totalVerificationsGlobal.toString()}`);
        console.log(`  üå≥ Companies Root Hash: ${stateBefore.companiesRootHash.toString()} ‚Üí ${stateAfter.companiesRootHash.toString()}`);
        console.log(`  üìù Registry Version: ${stateBefore.registryVersion.toString()} ‚Üí ${stateAfter.registryVersion.toString()}`);
        
        // Show compliance field analysis AFTER
        logComplianceFieldAnalysis(complianceData, isCompliant, 'Post-Verification');
        
        // Store verification result with detailed compliance data
        const analysis = analyzeComplianceFields(complianceData);
        verificationResults.push({
          companyName,
          lei: complianceData.lei.toString(),
          isCompliant: isCompliant.toJSON(),
          complianceScore: complianceAnalysis.complianceScore,
          verificationTime: currentTimestamp.toString(),
          complianceFields: {
            entityStatus: complianceData.entity_status.toString(),
            registrationStatus: complianceData.registration_status.toString(),
            conformityFlag: complianceData.conformity_flag.toString(),
            initialRegistrationDate: complianceData.initialRegistrationDate.toString(),
            lastUpdateDate: complianceData.lastUpdateDate.toString(),
            nextRenewalDate: complianceData.nextRenewalDate.toString(),
            bicCodes: complianceData.bic_codes.toString(),
            micCodes: complianceData.mic_codes.toString(),
            managingLou: complianceData.managing_lou.toString(),
          },
          businessRules: {
            entityActive: analysis.isEntityActive,
            registrationIssued: analysis.isRegistrationIssued,
            conformityOk: analysis.isConformityOk,
            validDates: analysis.hasValidDates,
            validLEI: analysis.hasValidLEI,
          },
          stateChanges: {
            totalCompaniesBefore: stateBefore.totalCompaniesTracked.toString(),
            totalCompaniesAfter: stateAfter.totalCompaniesTracked.toString(),
            compliantCompaniesBefore: stateBefore.compliantCompaniesCount.toString(),
            compliantCompaniesAfter: stateAfter.compliantCompaniesCount.toString(),
            globalScoreBefore: stateBeforeWithPercentage.compliancePercentage.toString(),
            globalScoreAfter: stateAfterWithPercentage.compliancePercentage.toString(),
          }
        });

      } catch (err: any) {
        console.error(`‚ùå Error processing ${companyName}:`, err.message);
        // Continue with other companies instead of stopping
        verificationResults.push({
          companyName,
          lei: 'ERROR',
          isCompliant: false,
          complianceScore: 0,
          verificationTime: Date.now().toString(),
          error: err.message
        });
        continue;
      }
    }

    // =================================== Final Analysis ===================================
    console.log(`\n${'='.repeat(80)}`);
    console.log(`üéâ GLEIF Multi-Company Compliance Verification Completed`);
    console.log(`${'='.repeat(80)}`);

    console.log('\nüìà Final Registry Statistics:');
    
    // Fetch final account state from DEVNET
    console.log(`üîÑ Fetching final zkApp account state from DEVNET...`);
    await fetchAccount({ publicKey: contractAddress });
    
    const finalStats = zkApp.getRegistryInfo();
    const finalStatsWithPercentage = addCompliancePercentage(finalStats);
    console.log(`  ‚Ä¢ Total Companies Tracked: ${finalStatsWithPercentage.totalCompanies}`);
    console.log(`  ‚Ä¢ Compliant Companies: ${finalStatsWithPercentage.compliantCompanies}`);
    console.log(`  ‚Ä¢ Compliance Percentage: ${finalStatsWithPercentage.compliancePercentage}%`);
    console.log(`  ‚Ä¢ Total Verifications: ${finalStats.totalVerificationsGlobal.toString()}`);
    if (finalStats.registryVersion && finalStats.registryVersion.toString() !== '0') {
      console.log(`  ‚Ä¢ Last Update: ${new Date(Number(finalStats.registryVersion.toString())).toISOString()}`);
    }

    console.log('\nüè¢ Companies Processed:');
    verificationResults.forEach((result, index) => {
      const status = result.error ? '‚ùå ERROR' : (result.isCompliant ? '‚úÖ COMPLIANT' : '‚ö†Ô∏è NON-COMPLIANT');
      console.log(`  ${index + 1}. ${result.companyName}: ${status}`);
      if (result.lei !== 'ERROR') {
        console.log(`     LEI: ${result.lei}`);
        console.log(`     Score: ${result.complianceScore}%`);
      }
      if (result.error) {
        console.log(`     Error: ${result.error}`);
      }
    });

    console.log('\nüìä Verification Summary:');
    const totalProcessed = verificationResults.length;
    const successfullyProcessed = verificationResults.filter(r => !r.error).length;
    const compliantCompanies = verificationResults.filter(r => r.isCompliant && !r.error).length;
    const errorCompanies = verificationResults.filter(r => r.error).length;

    console.log(`  ‚Ä¢ Total Companies: ${totalProcessed}`);
    console.log(`  ‚Ä¢ Successfully Processed: ${successfullyProcessed}`);
    console.log(`  ‚Ä¢ Compliant Companies: ${compliantCompanies}`);
    console.log(`  ‚Ä¢ Non-Compliant Companies: ${successfullyProcessed - compliantCompanies}`);
    console.log(`  ‚Ä¢ Error Companies: ${errorCompanies}`);
    
    if (successfullyProcessed > 0) {
      const overallComplianceRate = Math.round((compliantCompanies / successfullyProcessed) * 100);
      console.log(`  ‚Ä¢ Overall Compliance Rate: ${overallComplianceRate}%`);
    }

    return {
      proofs,
      totalCompanies: companyRegistry.getTotalCompanies(),
      companyRegistry: companyRegistry,
      contractState: zkApp.getRegistryInfo(),
      globalStats: await safeGetGlobalComplianceStats(zkApp, contractAddress, 'final_global_stats'),
      verificationResults,
      contractAddress: contractAddress.toBase58()
    };

  } catch (error) {
    console.error('‚ùå Error in GLEIF Multi-Company Compliance Verification:', error);
    throw error;
  }
}

/**
 * Main CLI function
 */
async function main() {
  const args = process.argv.slice(2);
  
  // Parse company names from command line arguments
  let companyNames: string[] = [];
  
  if (args.length === 0) {
    // Default companies for testing
    companyNames = [
      'Apple Inc',
      'Microsoft Corporation', 
      'Amazon.com Inc',
      'Alphabet Inc',
      'Tesla Inc'
    ];
    console.log('üè¢ No companies specified, using default list...');
  } else {
    companyNames = args;
  }
  
  console.log('üîç GLEIF Multi-Company Compliance Verifier');
  console.log('='.repeat(60));
  console.log(`üè¢ Companies to verify: ${companyNames.join(', ')}`);
  
  try {
    const result = await verifyGLEIFMultiCompanyCompliance(companyNames, true);
    
    console.log('\nüéâ VERIFICATION PROCESS COMPLETED SUCCESSFULLY!');
    console.log(`üìç Contract Address: ${result.contractAddress}`);
    console.log(`üè¢ Total Companies Verified: ${result.verificationResults.length}`);
    
    const successfulCount = result.verificationResults.filter(r => !r.error).length;
    const compliantCount = result.verificationResults.filter(r => r.isCompliant && !r.error).length;
    
    console.log(`‚úÖ Successfully Processed: ${successfulCount}`);
    console.log(`‚úÖ Compliant Companies: ${compliantCount}`);
    
    if (successfulCount > 0) {
      const complianceRate = Math.round((compliantCount / successfulCount) * 100);
      console.log(`üìä Overall Compliance Rate: ${complianceRate}%`);
    }
    
    console.log('\nüìã Next Steps:');
    console.log('  1. ‚úÖ Companies verified and recorded on blockchain');
    console.log('  2. üåê Check contract state on MinaScan or MinaExplorer');
    console.log('  3. üîÑ Run additional verifications as needed');
    
    process.exit(0);
    
  } catch (error) {
    console.error('üí• Fatal Error:', error);
    process.exit(1);
  }
}

// Run if called directly
main().catch(err => {
  console.error('üí• Fatal Error:', err);
  process.exit(1);
});